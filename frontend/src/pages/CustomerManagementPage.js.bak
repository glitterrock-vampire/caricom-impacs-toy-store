import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container, Typography, Box, Button, Dialog, DialogTitle, DialogContent, 
  DialogActions, Snackbar, Alert, CircularProgress, Card, CardContent,
  Chip, Avatar, IconButton, Menu, MenuItem, Table, TableBody,
  TableCell, TableContainer, TableHead, TableRow, Paper, Divider, Grid, 
  TextField, FormControl, InputLabel, Select,
  InputAdornment, OutlinedInput, Checkbox, ListItemText, ListItemIcon,
  Pagination, Tabs, Tab
} from '@mui/material';
import { 
  Add, MoreVert, Email, Phone, LocationOn, ShoppingCart, 
  TrendingUp, Visibility, Edit, Delete, Download, Search
} from '@mui/icons-material';
import { ThemeProvider } from '@mui/material/styles';
import { muiTheme } from '../theme/muiTheme';
import { customerService } from '../services/customerService';
import { reportService } from '../services/reportService';
import { format, parseISO, isValid } from 'date-fns';

// Status options for filtering
const statusOptions = [
  { value: 'active', label: 'Active' },
  { value: 'inactive', label: 'Inactive' },
  { value: 'vip', label: 'VIP' },
  { value: 'new', label: 'New' },
];

export default function CustomerManagementPage() {
  const [customers, setCustomers] = useState([]);
  const [orders, setOrders] = useState([]);
  const [filteredCustomers, setFilteredCustomers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [, setShowCreateForm] = useState(false);
  const [showAddDialog, setShowAddDialog] = useState(false);
  const [editingCustomer, setEditingCustomer] = useState(null);
  const [selectedCustomer, setSelectedCustomer] = useState(null);
  const [customerOrders, setCustomerOrders] = useState([]);
  const [showCustomerDetails, setShowCustomerDetails] = useState(false);
  const [isLoadingCustomer, setIsLoadingCustomer] = useState(false);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });
  const [anchorEl, setAnchorEl] = useState(null);
  const [menuCustomer, setMenuCustomer] = useState(null);
  const [tabValue, setTabValue] = useState(0);
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState([]);
  const [sortModel, setSortModel] = useState([{ field: 'name', sort: 'asc' }]);
  const [page, setPage] = useState(0);
  const [pageSize, setPageSize] = useState(10);
  const [rowCount, setRowCount] = useState(0);
  const [, setSelectedRows] = useState([]);
  // Theme and media query hooks - uncomment if needed
  // const theme = useTheme();
  // const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const navigate = useNavigate();

  const [newCustomer, setNewCustomer] = useState({
    name: '',
    email: '',
    phone: '',
    address: '',
    notes: '',
    status: 'active'
  });

  const handleViewCustomerOrders = (customerId) => {
    navigate(`/orders?customerId=${customerId}`);
  };

  // Enhanced customer data with orders
  const enhanceCustomerWithOrders = useCallback(async (customer) => {
    try {
      // If customer already has orders, return as is
      if (customer.orders && customer.orders.length > 0) {
        return customer;
      }
      
      // Otherwise, fetch the full customer data with orders
      const fullCustomer = await customerService.getCustomerById(customer.id);
      return fullCustomer;
    } catch (error) {
      console.error(`Error enhancing customer ${customer.id}:`, error);
      return customer; // Return original customer if there's an error
    }
  }, []);

  const handleViewCustomer = useCallback(async (customer) => {
    try {
      setIsLoadingCustomer(true);
      
      // Get the full customer data with orders
      const fullCustomer = await enhanceCustomerWithOrders(customer);
      
      // Update the customer in the state
      setCustomers(prevCustomers => 
        prevCustomers.map(c => c.id === fullCustomer.id ? fullCustomer : c)
      );
      
      // Set the selected customer and their orders
      setSelectedCustomer(fullCustomer);
      setCustomerOrders(fullCustomer.orders || []);
      
      // Log for debugging
      console.log('Viewing customer:', fullCustomer.id, 'with orders:', fullCustomer.orders?.length || 0);
      
      setShowCustomerDetails(true);
    } catch (error) {
      console.error('Error in handleViewCustomer:', error);
      setError('Failed to load customer details');
    } finally {
      setIsLoadingCustomer(false);
    }
  }, [enhanceCustomerWithOrders]);

  const handleCustomerClick = (customer) => {
    setSelectedCustomer(customer);
    setShowCustomerDetails(true);
  };

  const handleMenuClick = useCallback((event, customer) => {
    event.stopPropagation();
    setAnchorEl(event.currentTarget);
    setMenuCustomer(customer);
  }, []);

  // Columns for the data grid (unused but kept for future reference)
  // eslint-disable-next-line no-unused-vars
  const columns = [
    {
      field: 'name',
      headerName: 'Customer',
      flex: 1,
      minWidth: 200,
      renderCell: (params) => (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          <Avatar sx={{ bgcolor: 'primary.main' }}>
            {params.row.name?.charAt(0).toUpperCase()}
          </Avatar>
          <Box>
            <Typography variant="body1" noWrap>{params.row.name}</Typography>
            <Typography variant="body2" color="textSecondary" noWrap>{params.row.email}</Typography>
          </Box>
        </Box>
      ),
    },
    {
      field: 'phone',
      headerName: 'Phone',
      flex: 0.8,
      minWidth: 120,
    },
    {
      field: 'totalOrders',
      headerName: 'Orders',
      type: 'number',
      width: 100,
      align: 'center',
      headerAlign: 'center',
    },
    {
      field: 'totalSpent',
      headerName: 'Total Spent',
      type: 'number',
      width: 130,
      valueFormatter: (params) => `$${params.value?.toFixed(2) || '0.00'}`,
      headerAlign: 'right',
      align: 'right',
    },
    {
      field: 'lastOrder',
      headerName: 'Last Order',
      type: 'date',
      flex: 0.8,
      minWidth: 120,
      valueFormatter: (params) => 
        params.value ? format(new Date(params.value), 'MMM d, yyyy') : 'Never',
    },
    {
      field: 'status',
      headerName: 'Status',
      flex: 0.7,
      minWidth: 100,
      renderCell: (params) => {
        const status = params.value?.toLowerCase();
        const colorMap = {
          active: 'success',
          inactive: 'default',
          vip: 'warning',
          new: 'info',
        };
        return (
          <Chip 
            label={status} 
            color={colorMap[status] || 'default'}
            size="small"
            variant="outlined"
          />
        );
      },
    },
    {
      field: 'actions',
      headerName: 'Actions',
      type: 'actions',
      width: 100,
      getActions: (params) => [
        <IconButton 
          size="small" 
          onClick={() => handleViewCustomer(params.row)}
          title="View details"
        >
          <Visibility fontSize="small" />
        </IconButton>,
        <IconButton 
          size="small" 
          onClick={(e) => handleMenuClick(e, params.row)}
          title="More actions"
        >
          <MoreVert fontSize="small" />
        </IconButton>,
      ],
    }
  ];

  const formatAddress = (address) => {
    if (!address) return 'No address provided';
    const { street, city, state, postalCode, country } = address;
    return `${street}, ${city}, ${state} ${postalCode}, ${country}`;
  };

  // Fetch data with pagination and filters
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      // First, fetch all customers with their basic info
      const customersResponse = await customerService.getCustomers();
      const customersData = Array.isArray(customersResponse) 
        ? customersResponse 
        : customersResponse?.data || customersResponse?.customers || [];
      
      // Then fetch all orders with customer details
      const ordersResponse = await customerService.getAllOrders();
      const ordersData = Array.isArray(ordersResponse) 
        ? ordersResponse 
        : ordersResponse?.data || ordersResponse?.orders || [];

      console.log('Fetched customers:', customersData);
      console.log('Fetched orders:', ordersData);

      // Process customer data with their orders
      const processedCustomers = customersData.map(customer => {
        // Find all orders for this customer
        const customerOrders = ordersData.filter(order => {
          // Check both possible customer ID fields
          const orderCustomerId = order.customer_id || (order.customer && order.customer.id);
          return orderCustomerId === customer.id;
        });
        
        console.log(`Customer ${customer.id} has ${customerOrders.length} orders`);
        
        // Convert order dates to timestamps for sorting
        const sortedOrders = [...customerOrders].sort((a, b) => {
          const dateA = new Date(a.order_date || a.orderDate || a.createdAt).getTime();
          const dateB = new Date(b.order_date || b.orderDate || b.createdAt).getTime();
          return dateB - dateA; // Newest first
        });

        // Calculate total spent
        const totalSpent = sortedOrders.reduce((sum, order) => {
          const amount = parseFloat(order.total_amount || order.totalAmount || 0);
          return sum + (isNaN(amount) ? 0 : amount);
        }, 0);
        
        // Get the most recent order date
        const lastOrder = sortedOrders.length > 0 
          ? new Date(sortedOrders[0].order_date || sortedOrders[0].orderDate || sortedOrders[0].createdAt)
          : null;

        // Calculate average order value
        const avgOrderValue = sortedOrders.length > 0 
          ? totalSpent / sortedOrders.length 
          : 0;

        return {
          ...customer,
          orders: sortedOrders, // Store the actual order objects
          totalOrders: sortedOrders.length,
          totalSpent,
          lastOrder,
          lastOrderDate: lastOrder,
          avgOrderValue,
          status: customer.status || (sortedOrders.length > 0 ? 'active' : 'inactive')
        };
      });

      // Sort customers by most recent activity
      const sortedCustomers = [...processedCustomers].sort((a, b) => {
        if (!a.lastOrder && !b.lastOrder) return 0;
        if (!a.lastOrder) return 1;
        if (!b.lastOrder) return -1;
        return b.lastOrder.getTime() - a.lastOrder.getTime();
      });

      console.log('Processed customers:', sortedCustomers);
      
      setCustomers(sortedCustomers);
      setFilteredCustomers(sortedCustomers);
      setOrders(ordersData);
      setRowCount(sortedCustomers.length);
      
    } catch (err) {
      console.error('Error in fetchData:', err);
      setError(err.response?.data?.message || err.message || 'Failed to load data');
      setCustomers([]);
      setFilteredCustomers([]);
      setOrders([]);
    } finally {
      setLoading(false);
    }
  }, []);

  // Initial data fetch
  useEffect(() => {
    console.log('Component mounted, fetching data...');
    fetchData();
  }, [fetchData]);

  // Apply filters and search
  useEffect(() => {
    if (!customers.length) return;

    let result = [...customers];
    
    // Apply search
    if (searchTerm) {
      const searchLower = searchTerm.toLowerCase();
      result = result.filter(customer => 
        (customer.name?.toLowerCase().includes(searchLower)) ||
        (customer.email?.toLowerCase().includes(searchLower)) ||
        (customer.phone?.toLowerCase().includes(searchLower))
      );
    }
    
    // Apply status filter
    if (statusFilter.length > 0) {
      result = result.filter(customer => 
        statusFilter.includes(customer.status?.toLowerCase())
      );
    }
    
    // Apply sorting
    if (sortModel.length > 0) {
      const { field, sort } = sortModel[0];
      result.sort((a, b) => {
        let aValue = a[field];
        let bValue = b[field];
        
        if (aValue === bValue) return 0;
        if (aValue === null || aValue === undefined) return sort === 'asc' ? -1 : 1;
        if (bValue === null || bValue === undefined) return sort === 'asc' ? 1 : -1;
        
        if (typeof aValue === 'string') aValue = aValue.toLowerCase();
        if (typeof bValue === 'string') bValue = bValue.toLowerCase();
        
        return sort === 'asc' 
          ? aValue > bValue ? 1 : -1 
          : aValue < bValue ? 1 : -1;
      });
    }
    
    setFilteredCustomers(result);
    setRowCount(result.length);
  }, [customers, searchTerm, statusFilter, sortModel]);

  // Unused handler - keeping for future use
  // eslint-disable-next-line no-unused-vars
  const handleAddCustomer = async (customerData) => {
    try {
      const newCustomer = await customerService.createCustomer({
        ...customerData,
        status: 'active'
      });
      
      setCustomers(prev => [...prev, newCustomer]);
      setShowAddDialog(false);
      setSnackbar({
        open: true,
        message: 'Customer added successfully',
        severity: 'success'
      });
    } catch (error) {
      console.error('Error adding customer:', error);
      setSnackbar({
        open: true,
        message: 'Failed to add customer',
        severity: 'error'
      });
    }
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
    setMenuCustomer(null);
  };

  const handleExportReport = async () => {
    try {
      await reportService.exportCustomersReport('excel');
      setSnackbar({ open: true, message: 'Customer report exported successfully!', severity: 'success' });
    } catch (error) {
      console.error('Error exporting report:', error);
      setSnackbar({ open: true, message: 'Failed to export report', severity: 'error' });
    }
  };

  // Helper function to safely format dates
  const safeFormatDate = (dateString, formatString = 'MMM d, yyyy') => {
    if (!dateString) return 'N/A';
    try {
      const date = typeof dateString === 'string' ? parseISO(dateString) : new Date(dateString);
      return isValid(date) ? format(date, formatString) : 'N/A';
    } catch (e) {
      console.error('Error formatting date:', e);
      return 'N/A';
    }
  };

  // Helper function to get customer stats
  const getCustomerStats = useCallback((customerId) => {
    // Find the customer first
    const customer = customers.find(c => c.id === customerId);
    if (!customer) {
      console.error('Customer not found:', customerId);
      return {
        totalOrders: 0,
        totalSpent: 0,
        lastOrder: null,
        lastOrderDate: null,
        avgOrderValue: 0,
        status: 'Inactive'
      };
    }

    // Use orders from customer object if available, otherwise filter from orders array
    const customerOrders = customer.orders || 
      orders.filter(order => 
        order.customer_id === customerId || 
        order.customerId === customerId
      );

    console.log(`Stats for customer ${customerId}:`, customerOrders.length, 'orders found');

    // Calculate total spent by summing all order amounts
    const totalSpent = customerOrders.reduce((sum, order) => {
      const amount = parseFloat(order.total_amount || order.totalAmount || 0);
      return sum + (isNaN(amount) ? 0 : amount);
    }, 0);

    // Find most recent order
    let lastOrder = null;
    let lastOrderDate = null;
    
    if (customerOrders.length > 0) {
      try {
        // Find the most recent order by date
        const sortedOrders = [...customerOrders].sort((a, b) => {
          const dateA = new Date(a.order_date || a.orderDate || a.createdAt).getTime();
          const dateB = new Date(b.order_date || b.orderDate || b.createdAt).getTime();
          return dateB - dateA; // Sort descending
        });

        if (sortedOrders.length > 0) {
          lastOrder = sortedOrders[0];
          lastOrderDate = new Date(lastOrder.order_date || lastOrder.orderDate || lastOrder.createdAt);
        }
      } catch (e) {
        console.error('Error processing order dates:', e);
      }
    }

    // Calculate average order value
    const avgOrderValue = customerOrders.length > 0 
      ? totalSpent / customerOrders.length 
      : 0;

    // Determine status based on order activity
    const status = customer.status || (customerOrders.length > 0 ? 'Active' : 'Inactive');

    return {
      totalOrders: customerOrders.length,
      totalSpent,
      lastOrder,
      lastOrderDate,
      avgOrderValue,
      status
    };
  }, [customers, orders]);

  const handleEditCustomer = (customer) => {
    setEditingCustomer(customer);
    setNewCustomer({
      name: customer.name,
      email: customer.email,
      phone: customer.phone,
      address: customer.address || '',
      notes: customer.notes || '',
      status: customer.status || 'active'
    });
    setShowCreateForm(true);
    handleMenuClose();
  };

  // Handle deleting a customer
  const handleDeleteCustomer = async (customerId) => {
    try {
      await customerService.deleteCustomer(customerId);
      setCustomers(prev => prev.filter(c => c.id !== customerId));
      setFilteredCustomers(prev => prev.filter(c => c.id !== customerId));
      setOrders(prev => prev.filter(o => o.customer_id !== customerId));
      setSnackbar({ open: true, message: 'Customer deleted successfully!', severity: 'success' });
      handleMenuClose();
    } catch (error) {
      console.error('Error deleting customer:', error);
      setSnackbar({ 
        open: true, 
        message: error.response?.data?.error || 'Failed to delete customer', 
        severity: 'error' 
      });
    }
  };

  // Handle form input changes
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setNewCustomer(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      setLoading(true);
      
      if (editingCustomer) {
        // Update existing customer
        const updatedCustomer = await customerService.updateCustomer(
          editingCustomer.id, 
          newCustomer
        );
        
        setCustomers(prev => 
          prev.map(c => c.id === updatedCustomer.id ? updatedCustomer : c)
        );
        setFilteredCustomers(prev => 
          prev.map(c => c.id === updatedCustomer.id ? updatedCustomer : c)
        );
        
        setSnackbar({ 
          open: true, 
          message: 'Customer updated successfully!', 
          severity: 'success' 
        });
      } else {
        // Create new customer
        const createdCustomer = await customerService.createCustomer(newCustomer);
        
        setCustomers(prev => [...prev, createdCustomer]);
      
      console.log('Fetched customers:', customersData);
      
      // Enhance each customer with their full order data
      const enhancedCustomers = await Promise.all(
        customersData.map(customer => enhanceCustomerWithOrders(customer))
      );
      
      setCustomers(enhancedCustomers);
      setFilteredCustomers(enhancedCustomers);
      
      // Extract and set all orders for the dashboard
      const allOrders = enhancedCustomers.flatMap(customer => 
        (customer.orders || []).map(order => ({
          ...order,
          customerName: customer.name,
          customerId: customer.id
        }))
  // Handle sort model change
  // Unused handler - keeping for future use
  // eslint-disable-next-line no-unused-vars
  const handleSortModelChange = (newSortModel) => {
    setSortModel(newSortModel);
  };

  // Handle page change
  const handlePageChange = (newPage) => {
    setPage(newPage);
  };

  // Handle page size change
  // Unused handler - keeping for future use
  // eslint-disable-next-line no-unused-vars
  const handlePageSizeChange = (newPageSize) => {
    setPageSize(newPageSize);
    setPage(0); // Reset to first page when changing page size
  };

  // Handle row selection
  // Unused handler - keeping for future use
  // eslint-disable-next-line no-unused-vars
  const handleSelectionModelChange = (newSelection) => {
    setSelectedRows(newSelection);
  };

  // Handle refresh button click
  const handleRefresh = () => {
    fetchData();
  };

  // Handle clear filters
  const handleClearFilters = () => {
    setSearchTerm('');
    setStatusFilter([]);
    setSortModel([{ field: 'name', sort: 'asc' }]);
    setPage(0);
  };

  // Check if any filters are active
  const hasActiveFilters = searchTerm || statusFilter.length > 0 || 
    (sortModel.length > 0 && sortModel[0].field !== 'name');

  // Calculate paginated data
  const paginatedCustomers = filteredCustomers.slice(
    page * pageSize,
    (page + 1) * pageSize
  );

  // Unused component - keeping for future use
  // eslint-disable-next-line no-unused-vars
  const CustomerCard = ({ customer }) => {
    const stats = getCustomerStats(customer.id);
    
    return (
      <Card 
        sx={{ 
          height: '100%', 
          cursor: 'pointer',
          transition: 'all 0.3s ease',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: 4
          }
        }}
        onClick={() => handleCustomerClick(customer)}
      >
        <CardContent>
          <Box display="flex" justifyContent="space-between" alignItems="flex-start" mb={2}>
            <Box display="flex" alignItems="center">
              <Avatar sx={{ bgcolor: 'primary.main', mr: 2 }}>
                {customer.name?.charAt(0).toUpperCase()}
              </Avatar>
              <Box>
                <Typography variant="h6" component="h3" noWrap>
                  {customer.name}
                </Typography>
                <Chip 
                  label={customer.status || 'inactive'} 
                  size="small" 
                  color={stats.status === 'Active' ? 'success' : 'default'}
                />
              </Box>
            </Box>
            <IconButton 
              size="small"
              onClick={(e) => handleMenuClick(e, customer)}
            >
              <MoreVert />
            </IconButton>
          </Box>

          <Box mb={2}>
            <Box display="flex" alignItems="center" mb={1}>
              <Email sx={{ fontSize: 16, mr: 1, color: 'text.secondary' }} />
              <Typography variant="body2" color="text.secondary" noWrap>
                {customer.email}
              </Typography>
            </Box>
            <Box display="flex" alignItems="center">
              <Phone sx={{ fontSize: 16, mr: 1, color: 'text.secondary' }} />
              <Typography variant="body2" color="text.secondary">
                {customer.phone}
              </Typography>
            </Box>
          </Box>

          <Divider sx={{ my: 2 }} />

          <Grid container spacing={2}>
            <Grid item xs={6}>
              <Box textAlign="center">
                <Typography variant="h6" color="primary">
                  {stats.totalOrders}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Orders
                </Typography>
              </Box>
            </Grid>
            <Grid item xs={6}>
              <Box textAlign="center">
                <Typography variant="h6" color="success.main">
                  ${stats.totalSpent.toFixed(2)}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Total Spent
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </CardContent>
      </Card>
    );
  };

  const CustomerDetailsDialog = () => {
    if (!selectedCustomer) return null;

    const stats = getCustomerStats(selectedCustomer.id);
    // First try to get orders from the customer object, then fall back to filtering all orders
    const customerOrders = selectedCustomer.orders || 
      orders.filter(order => 
        order.customerId === selectedCustomer.id || 
        order.customer_id === selectedCustomer.id
      );
    
    console.log('Customer Orders:', customerOrders); // Debug log

    return (
      <Dialog 
        open={showCustomerDetails} 
        onClose={() => setShowCustomerDetails(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          <Box display="flex" alignItems="center" justifyContent="space-between">
            <Box display="flex" alignItems="center">
              <Avatar sx={{ bgcolor: 'primary.main', mr: 2, width: 56, height: 56 }}>
                {selectedCustomer.name.charAt(0).toUpperCase()}
              </Avatar>
              <Box>
                <Typography variant="h5">{selectedCustomer.name}</Typography>
                <Chip 
                  label={stats.status} 
                  color={stats.status === 'Active' ? 'success' : 'default'}
                />
              </Box>
            </Box>
            <Button
              variant="outlined"
              startIcon={<Edit />}
              onClick={() => {
                handleEditCustomer(selectedCustomer);
                setShowCustomerDetails(false);
              }}
            >
              Edit
            </Button>
          </Box>
        </DialogTitle>
        
        <DialogContent>
          <Tabs value={tabValue} onChange={(e, newValue) => setTabValue(newValue)}>
            <Tab label="Overview" />
            <Tab label="Order History" />
          </Tabs>

          {tabValue === 0 && (
            <Box mt={3}>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <Card>
                    <CardContent>
                      <Typography variant="h6" gutterBottom>Contact Information</Typography>
                      <Box mb={2}>
                        <Box display="flex" alignItems="center" mb={1}>
                          <Email sx={{ mr: 1, color: 'text.secondary' }} />
                          <Typography>{selectedCustomer.email}</Typography>
                        </Box>
                        <Box display="flex" alignItems="center" mb={1}>
                          <Phone sx={{ mr: 1, color: 'text.secondary' }} />
                          <Typography>{selectedCustomer.phone}</Typography>
                        </Box>
                        {selectedCustomer && selectedCustomer.address && (
                          <Box display="flex" alignItems="center">
                            <LocationOn sx={{ mr: 1, color: 'text.secondary' }} />
                            <Typography>{formatAddress(selectedCustomer.address)}</Typography>
                          </Box>
                        )}
                      </Box>
                      {selectedCustomer.notes && (
                        <Box>
                          <Typography variant="subtitle2" gutterBottom>Notes</Typography>
                          <Typography variant="body2" color="text.secondary">
                            {selectedCustomer.notes}
                          </Typography>
                        </Box>
                      )}
                    </CardContent>
                  </Card>
                </Grid>
                
                <Grid item xs={12} md={6}>
                  <Card>
                    <CardContent>
                      <Typography variant="h6" gutterBottom>Customer Statistics</Typography>
                      <Grid container spacing={2}>
                        <Grid item xs={6}>
                          <Box textAlign="center" p={2}>
                            <ShoppingCart sx={{ fontSize: 40, color: 'primary.main', mb: 1 }} />
                            <Typography variant="h4">{stats.totalOrders}</Typography>
                            <Typography variant="body2" color="text.secondary">Total Orders</Typography>
                          </Box>
                        </Grid>
                        <Grid item xs={6}>
                          <Box textAlign="center" p={2}>
                            <TrendingUp sx={{ fontSize: 40, color: 'success.main', mb: 1 }} />
                            <Typography variant="h4">${stats.totalSpent.toFixed(0)}</Typography>
                            <Typography variant="body2" color="text.secondary">Total Spent</Typography>
                          </Box>
                        </Grid>
                        <Grid item xs={6}>
                          <Box textAlign="center" p={2}>
                            <Typography variant="h5">${stats.avgOrderValue.toFixed(2)}</Typography>
                            <Typography variant="body2" color="text.secondary">Avg Order Value</Typography>
                          </Box>
                        </Grid>
                        <Grid item xs={6}>
                          <Box textAlign="center" p={2}>
                            <Typography variant="h6">
                              {stats.lastOrder ? safeFormatDate(stats.lastOrder) : 'Never'}
                            </Typography>
                            <Typography variant="body2" color="text.secondary">Last Order</Typography>
                          </Box>
                        </Grid>
                      </Grid>
                    </CardContent>
                  </Card>
                </Grid>
              </Grid>
            </Box>
          )}

          {tabValue === 1 && (
            <Box mt={3}>
              <TableContainer component={Paper}>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Order ID</TableCell>
                      <TableCell>Date</TableCell>
                      <TableCell>Status</TableCell>
                      <TableCell align="right">Amount</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {customerOrders.map((order) => (
                      <TableRow key={order.id}>
                        <TableCell>#{order.id}</TableCell>
                        <TableCell>{safeFormatDate(order.order_date)}</TableCell>
                        <TableCell>
                          <Chip 
                            label={order.status} 
                            size="small"
                            color={order.status === 'delivered' ? 'success' : 'default'}
                          />
                        </TableCell>
                        <TableCell align="right">${order.total_amount?.toFixed(2) || '0.00'}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </Box>
          )}
        </DialogContent>
        
        <DialogActions>
          <Button onClick={() => setShowCustomerDetails(false)}>Close</Button>
        </DialogActions>
      </Dialog>
    );
  };

  // Add Customer Dialog Component
  const AddCustomerDialog = () => (
    <Dialog open={showAddDialog} onClose={() => setShowAddDialog(false)} maxWidth="sm" fullWidth>
      <DialogTitle>Add New Customer</DialogTitle>
      <form onSubmit={handleSubmit}>
        <DialogContent>
          <Box display="flex" flexDirection="column" gap={2}>
            <TextField
              name="name"
              label="Full Name"
              value={newCustomer.name}
              onChange={handleInputChange}
              required
              fullWidth
            />
            <TextField
              name="email"
              label="Email"
              type="email"
              value={newCustomer.email}
              onChange={handleInputChange}
              required
              fullWidth
            />
            <TextField
              name="phone"
              label="Phone Number"
              value={newCustomer.phone}
              onChange={handleInputChange}
              fullWidth
            />
            <TextField
              name="address"
              label="Address"
              value={newCustomer.address}
              onChange={handleInputChange}
              multiline
              rows={2}
              fullWidth
            />
            <TextField
              name="notes"
              label="Notes"
              value={newCustomer.notes}
              onChange={handleInputChange}
              multiline
              rows={3}
              fullWidth
            />
            <FormControl fullWidth>
              <InputLabel>Status</InputLabel>
              <Select
                name="status"
                value={newCustomer.status}
                onChange={handleInputChange}
                label="Status"
                required
                >
                  {statusOptions.map((option) => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setShowAddDialog(false)}>Cancel</Button>
            <Button type="submit" variant="contained" color="primary">
              {editingCustomer ? 'Update Customer' : 'Add Customer'}
            </Button>
          </DialogActions>
        </form>
      </Dialog>
    );
    
    // Main component render
    return (
      <ThemeProvider theme={muiTheme}>
        <Container maxWidth="xl" sx={{ py: 4 }}>
          <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
            <Typography variant="h4" component="h1">
              Customer Management
            </Typography>
            <Box display="flex" gap={2}>
              <Button 
                variant="contained" 
                startIcon={<Download />}
                onClick={handleExportReport}
              >
                Export
              </Button>
              <Button 
                variant="contained" 
                color="primary" 
                startIcon={<Add />}
                onClick={() => {
                  setNewCustomer({
                    name: '',
                    email: '',
                    phone: '',
                    address: '',
                    notes: '',
                    status: 'active'
                  });
                  setEditingCustomer(null);
                  setShowAddDialog(true);
                }}
              >
                Add Customer
              </Button>
            </Box>
          </Box>
    
          {/* Filters and Search */}
          <Card sx={{ mb: 3 }}>
            <CardContent>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <TextField
                    fullWidth
                    variant="outlined"
                    placeholder="Search customers..."
                    value={searchTerm}
                    onChange={handleSearchChange}
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Search />
                        </InputAdornment>
                      ),
                    }}
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <FormControl fullWidth>
                    <InputLabel>Status Filter</InputLabel>
                    <Select
                      multiple
                      value={statusFilter}
                      onChange={handleStatusFilterChange}
                      input={<OutlinedInput label="Status Filter" />}
                      renderValue={(selected) => (
                        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                          {selected.map((value) => (
                            <Chip 
                              key={value} 
                              label={statusOptions.find(o => o.value === value)?.label || value} 
                            />
                          ))}
                        </Box>
                      )}
                    >
                      {statusOptions.map((option) => (
                        <MenuItem key={option.value} value={option.value}>
                          <Checkbox checked={statusFilter.indexOf(option.value) > -1} />
                          <ListItemText primary={option.label} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                <Grid item xs={12} md={2}>
                  <Button
                    fullWidth
                    variant="outlined"
                    onClick={handleClearFilters}
                    disabled={!hasActiveFilters}
                  >
                    Clear Filters
                  </Button>
                </Grid>
              </Grid>
            </CardContent>
          </Card>
    
          {/* Loading State */}
          {loading && (
            <Box display="flex" justifyContent="center" my={4}>
              <CircularProgress />
            </Box>
          )}
    
          {/* Error State */}
          {error && !loading && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
              <Button color="inherit" size="small" onClick={handleRefresh}>
                Retry
              </Button>
            </Alert>
          )}
    
          {/* Empty State */}
          {!loading && !error && filteredCustomers.length === 0 && (
            <Box textAlign="center" py={6}>
              <img 
                src="/images/empty-customers.svg" 
                alt="No customers found" 
                style={{ height: 200, marginBottom: 16 }} 
              />
              <Typography variant="h6" gutterBottom>
                {hasActiveFilters ? 'No matching customers found' : 'No customers yet'}
              </Typography>
              <Typography color="textSecondary" paragraph>
                {hasActiveFilters
                  ? 'Try adjusting your search or filter criteria'
                  : 'Get started by adding your first customer'}
              </Typography>
              <Button
                variant="contained"
                color="primary"
                startIcon={<Add />}
                onClick={() => setShowAddDialog(true)}
              >
                Add Customer
              </Button>
            </Box>
          )}
    
          {/* Data Grid */}
          {!loading && !error && filteredCustomers.length > 0 && (
            <>
              <TableContainer component={Paper}>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Customer</TableCell>
                      <TableCell>Contact</TableCell>
                      <TableCell align="center">Orders</TableCell>
                      <TableCell align="right">Total Spent</TableCell>
                      <TableCell>Last Order</TableCell>
                      <TableCell>Status</TableCell>
                      <TableCell>Actions</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {paginatedCustomers.map((customer) => (
                      <TableRow 
                        key={customer.id} 
                        hover 
                        sx={{ '&:hover': { cursor: 'pointer' } }}
                        onClick={() => handleViewCustomer(customer)}
                      >
                        <TableCell>
                          <Box display="flex" alignItems="center" gap={2}>
                            <Avatar sx={{ bgcolor: 'primary.main' }}>
                              {customer.name?.charAt(0).toUpperCase()}
                            </Avatar>
                            <Box>
                              <Typography variant="body1" noWrap>{customer.name}</Typography>
                              <Typography variant="body2" color="textSecondary" noWrap>
                                {customer.email}
                              </Typography>
                            </Box>
                          </Box>
                        </TableCell>
                        <TableCell>
                          <Typography>{customer.phone}</Typography>
                        </TableCell>
                        <TableCell align="center">
                          <Typography>{customer.totalOrders}</Typography>
                        </TableCell>
                        <TableCell align="right">
                          <Typography>${customer.totalSpent?.toFixed(2) || '0.00'}</Typography>
                        </TableCell>
                        <TableCell>
                          <Typography>
                            {safeFormatDate(customer.lastOrderDate)}
                          </Typography>
                        </TableCell>
                        <TableCell>
                          <Chip 
                            label={customer.status} 
                            color={
                              customer.status === 'active' ? 'success' : 
                              customer.status === 'vip' ? 'warning' : 
                              customer.status === 'new' ? 'info' : 'default'
                            }
                            size="small"
                            variant="outlined"
                          />
                        </TableCell>
                        <TableCell>
                          <IconButton 
                            size="small" 
                            onClick={(e) => {
                              e.stopPropagation();
                              handleMenuClick(e, customer);
                            }}
                          >
                            <MoreVert />
                          </IconButton>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
    
              {/* Pagination */}
              <Box display="flex" justifyContent="space-between" alignItems="center" mt={2}>
                <Typography variant="body2" color="textSecondary">
                  Showing {Math.min(page * pageSize + 1, rowCount)} to {Math.min((page + 1) * pageSize, rowCount)} of {rowCount} customers
                </Typography>
                <Pagination
                  count={Math.ceil(rowCount / pageSize)}
                  page={page + 1}
                  onChange={(event, value) => handlePageChange(value - 1)}
                  color="primary"
                  showFirstButton
                  showLastButton
                />
              </Box>
            </>
          )}
    
          {/* Action Menu */}
          <Menu
            anchorEl={anchorEl}
            open={Boolean(anchorEl)}
            onClose={handleMenuClose}
            onClick={(e) => e.stopPropagation()}
          >
            <MenuItem 
              onClick={() => {
                handleViewCustomer(menuCustomer);
                handleMenuClose();
              }}
            >
              <ListItemIcon>
                <Visibility fontSize="small" />
              </ListItemIcon>
              <ListItemText>View Details</ListItemText>
            </MenuItem>
            <MenuItem 
              onClick={() => {
                handleEditCustomer(menuCustomer);
                handleMenuClose();
              }}
            >
              <ListItemIcon>
                <Edit fontSize="small" />
              </ListItemIcon>
              <ListItemText>Edit</ListItemText>
            </MenuItem>
            <MenuItem 
              onClick={() => {
                handleViewCustomerOrders(menuCustomer.id);
                handleMenuClose();
              }}
            >
              <ListItemIcon>
                <ShoppingCart fontSize="small" />
              </ListItemIcon>
              <ListItemText>View Orders</ListItemText>
            </MenuItem>
            <Divider />
            <MenuItem 
              onClick={() => {
                handleDeleteCustomer(menuCustomer.id);
              }}
              sx={{ color: 'error.main' }}
            >
              <ListItemIcon>
                <Delete fontSize="small" color="error" />
              </ListItemIcon>
              <ListItemText>Delete</ListItemText>
            </MenuItem>
          </Menu>
    
          {/* Customer Details Dialog */}
          <CustomerDetailsDialog />
    
          {/* Add/Edit Customer Dialog */}
          <AddCustomerDialog />
    
          {/* Snackbar for notifications */}
          <Snackbar
            open={snackbar.open}
            autoHideDuration={6000}
            onClose={() => setSnackbar({ ...snackbar, open: false })}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
          >
            <Alert 
              onClose={() => setSnackbar({ ...snackbar, open: false })}
              severity={snackbar.severity}
              sx={{ width: '100%' }}
            >
              {snackbar.message}
            </Alert>
          </Snackbar>
        </Container>
      </ThemeProvider>
    );
  }